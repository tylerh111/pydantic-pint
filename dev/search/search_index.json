{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Pydantic Pint","text":"<p>Pydantic is a Python library for data validation and data serialization. Pint is a Python library for defining, operating, and manipulating physical quantities. By default, they do not play well with each other.</p> <p>Many projects that have a need for data validation may also need to work with physical quantities. Pydantic Pint aims to bridge that gap by providing Pydantic validation for Pint quantities.</p> <pre><code>from pydantic import BaseModel\nfrom pydantic_pint import PydanticPintQuantity\nfrom pint import Quantity\nfrom typing import Annotated\n\nclass Box(BaseModel):\n    length: Annotated[Quantity, PydanticPintQuantity(\"m\")]\n    width: Annotated[Quantity, PydanticPintQuantity(\"m\")]\n\nbox = Box(\n    length=\"4m\",\n    width=\"2m\",\n)\n</code></pre>"},{"location":"#getting-started","title":"Getting Started","text":""},{"location":"#installation","title":"Installation","text":"<p>Pydantic Pint is available as <code>pydantic-pint</code> on PyPI.</p> <p>Pydantic Pint requires both Pydantic and Pint to be installed. It also requires <code>typing.Annotated</code> (for older version of python use <code>typing_extensions</code>).</p> <pre><code>pip install pydantic-pint\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>Pydantic Pint provides <code>PydanticPintQuantity</code> which enabled Pydantic validation for Pint quantities. For a field of a Pydantic model to have quantity validation, it must be annotated with a <code>PydanticPintQuantity</code> for a given unit.</p> <pre><code>from pydantic import BaseModel\nfrom pydantic_pint import PydanticPintQuantity\nfrom pint import Quantity\nfrom typing import Annotated\n\nclass Coordinates(BaseModel):\n    latitude: Annotated[Quantity, PydanticPintQuantity(\"deg\")]\n    longitude: Annotated[Quantity, PydanticPintQuantity(\"deg\")]\n    altitude: Annotated[Quantity, PydanticPintQuantity(\"km\")]\n</code></pre> <p>Users of the model can input anything to the field with a specified unit that is convertible to the units declared in the annotation. For instance, the units for <code>Coordinates.altitude</code> are kilometers, however users can specify meters instead. <code>PydanticPintQuantity</code> will handle the conversion from meters to kilometers.</p> <pre><code>coord = Coordinates(\n    latitude=\"39.905705 deg\",\n    longitude=\"-75.166519 deg\",\n    altitude=\"12 meters\",\n)\n\nprint(coord)\n#&gt; latitude=&lt;Quantity(39.905705, 'degree')&gt; longitude=&lt;Quantity(-75.166519, 'degree')&gt; altitude=&lt;Quantity(0.012, 'kilometer')&gt;\nprint(f\"{coord!r}\")\n#&gt; Coordinates(latitude=&lt;Quantity(39.905705, 'degree')&gt;, longitude=&lt;Quantity(-75.166519, 'degree')&gt;, altitude=&lt;Quantity(0.012, 'kilometer')&gt;)\nprint(coord.model_dump())\n#&gt; {'latitude': &lt;Quantity(39.905705, 'degree')&gt;, 'longitude': &lt;Quantity(-75.166519, 'degree')&gt;, 'altitude': &lt;Quantity(0.012, 'kilometer')&gt;}\nprint(coord.model_dump(mode=\"json\"))\n#&gt; {'latitude': '39.905705 degree', 'longitude': '-75.166519 degree', 'altitude': '0.012 kilometer'}\nprint(f\"{coord.model_dump_json()!r}\")\n#&gt; '{\"latitude\":\"39.905705 degree\",\"longitude\":\"-75.166519 degree\",\"altitude\":\"0.012 kilometer\"}'\n</code></pre>"},{"location":"changes/","title":"Changes","text":"<p>All notable changes to this project will be documented in this file.</p>"},{"location":"changes/#unreleased","title":"Unreleased","text":""},{"location":"changes/#02---2025-03-30","title":"0.2 - 2025-03-30","text":""},{"location":"changes/#added","title":"Added","text":"<ul> <li>Added <code>\"number\"</code> serialization mode to allow users to drop units when serializing a field. (1)</li> <li>Allow dimensions restriction on fields using <code>PydanticPintQuantity</code>.   Default changed to automatically deduce restrictions instead of only allowing units.   Using <code>restriction=\"units\"</code> forces the restriction to be on units. (4)</li> <li>Added <code>exact</code> option to <code>PydanticPintQuantity</code>.   Enabling this flags forces users to match the exact units of the field. (11)</li> <li>Added wrapper class for <code>pint.Quantity</code> instance to allow value restrictions with <code>pydantic.Field</code>.   Restrictions with <code>pydantic.Field</code> and <code>PydanticPintValue</code> must be specified as an annotation. (16)</li> <li>Added unit tests for all advertised features. (34)</li> </ul>"},{"location":"changes/#changed","title":"Changed","text":"<ul> <li>Changed schema to allow units to be optional when validating a dictionary.   The check for requiring units happens later in validation by using <code>strict</code>. (29)</li> </ul>"},{"location":"changes/#fixed","title":"Fixed","text":"<ul> <li>Fixed issue where <code>PydanticPintQuantity</code> fields cannot be used with each other due to different unit registries. (7)</li> <li>Fixed issue where <code>PydanticPintValue</code> did not use global registry. (18)</li> <li>Refactored validation check on quantity making it simpler to follow.   The issue regarding strict mode not properly failing validation is fixed as well. (27)</li> <li>Fixed validation of dimensions when using custom contexts.   Now, custom contexts that are enabled in the unit registry will be utilized during the check.   To use the old behavior, enable exact mode which forces the users to provide units of the exact dimensions. (28)</li> </ul>"},{"location":"changes/#01---2024-05-06","title":"0.1 - 2024-05-06","text":""},{"location":"changes/#added_1","title":"Added","text":"<ul> <li>Added initial code, docs, and tools.</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>Thank you for taking the time to contribute to Pydantic Pint! All types of contributions are encouraged and valued. Please refer to this page for ways to contribute.</p>"},{"location":"contributing/#overview","title":"Overview","text":"<p>There are plenty of ways to support the project and show your appreciation!</p> <ul> <li>Create and comment on issues.</li> <li>Create and comment on pull requests.</li> <li>Fork the project.</li> <li>Star the project.</li> <li>Watch the project.</li> <li>Talk about the project!</li> </ul>"},{"location":"contributing/#creating-issues","title":"Creating Issues","text":"<p>GitHub issues track any enhancements, bugs, questions, or suggestions for this project.</p> <ul> <li>Open an issue.</li> <li>Provide as much detail as you can.</li> <li>Provide project and platform version (python, pydantic, pint, etc.).</li> </ul>"},{"location":"contributing/#asking-questions","title":"Asking Questions","text":"<p>If you have a question, create an issue with the <code>question</code> label. We will try to answer it as best we can.</p> <p>Provide the following information when asking questions.</p> <ul> <li>Ask the question in a clear and concise manner.</li> <li>Search and link relevant issues and pull requests.</li> <li>Provide details and context separate from the question.   In other words, the question and context should be separate.   This makes it easier to answer the question if it is clearly stated.   Anything passed that can be a discussion.</li> </ul>"},{"location":"contributing/#requesting-features","title":"Requesting Features","text":"<p>If you have an idea for enhancements, open an issue with the <code>enhancement</code> label. We will determine if such an enhancement is worth implementing. Enhancements should improve the use of the project without breaking the existing functionality.</p> <p>Provide the following information when requesting features.</p> <ul> <li>Explain what currently does not exist with the project.</li> <li>Explain how the feature request can address the issue.</li> <li>Include usecases for the feature.</li> <li>Include examples for using the feature.</li> </ul>"},{"location":"contributing/#reporting-bugs","title":"Reporting Bugs","text":"<p>If you find a bug, open an issue with the <code>bug</code> label. Bug reports should contain information about the environment in which you are running. This is key in order to replicate the issue to further investigate and fix it.</p> <p>Provide the following information when reporting a bug.</p> <ul> <li>Environment, including project and platform information (python, pydantic, pint, etc.).</li> <li>Current behavior, include examples for replication.</li> <li>Expected behavior, include examples for verification.</li> </ul>"},{"location":"contributing/#updating-documentation","title":"Updating Documentation","text":"<p>If you think the documentation should be updated, open an issue with the <code>documentation</code> label. Documentation might have small issues that need fixed, e.g. misspellings or grammar mistakes, or might be related to enhancements or bugs, e.g. new or changed functionality.</p> <p>Provide the following information when updating the documentation.</p> <ul> <li>The documentation page that should be added.</li> <li>The documentation page that should be modified.</li> <li>The documentation page that should be removed.</li> <li>Updates to examples.</li> </ul>"},{"location":"contributing/#creating-pull-requests","title":"Creating Pull Requests","text":"<p>GitHub pull requests address the issues of the project.</p> <ul> <li>Fork the project.</li> <li>Create a branch from the latest revision on <code>main</code>.</li> <li>Implement the changes to address a particular issue(s).</li> <li>Open a pull request.</li> <li>Add the issue number to the description of the pull request.   It should be clear which issue (or issues) are addressed.</li> </ul>"},{"location":"contributing/#fixing-bugs","title":"Fixing Bugs","text":"<p>Fixing a bug should have an associated issue labeled as a <code>bug</code>. Make sure the bug is fixed correctly and completely. The following additions to your bugfix could help improve it.</p> <ul> <li>Add unit tests to cover the bugfix.   This ensures that it never pops back up.</li> <li>Test all facets of your changes so that no other parts of the code base breaks.   Check how the new feature interacts with other features.</li> <li>Make sure each commit is deliberate and meaningful.   Changes like spacing, formatting, or typos (in unrelated locations) are not necessary to change while implementing a feature or bugfix.   Ensure other parts of the code have not been modified that do not need to be modified to implement your feature or bugfix.</li> <li>Limit the size of your changes.   Large diffs can be difficult to verify and validate.</li> </ul>"},{"location":"contributing/#implementing-features","title":"Implementing Features","text":"<p>Implementing a feature should have an associated issue labeled as an <code>enhancement</code>. Make sure the feature is implemented correctly and completely. The following additions to your feature could help improve it.</p> <ul> <li>Add documentation.</li> <li>Add unit tests.   Check corner cases, and how the feature works with bad or invalid input.</li> <li>Test all facets of your changes so that no other parts of the code base breaks.   Check how the new feature interacts with other features.</li> <li>Make sure each commit is deliberate and meaningful.   Changes like spacing, formatting, or typos (in unrelated locations) are not necessary to change while implementing a feature or bugfix.   Ensure other parts of the code have not been modified that do not need to be modified to implement your feature or bugfix.</li> <li>Limit the size of your changes.   Large diffs can be difficult to verify and validate.</li> </ul>"},{"location":"contributing/#thank-you","title":"Thank You!","text":"<p>You are help Pydantic Pint grow and prosper with your involvement. We hope to see your contributions in the project soon!</p>"},{"location":"license/","title":"License","text":"<p>MIT License</p> <p>Copyright \u00a9 2024-2025 Tyler Hughes</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#quantity-validation","title":"Quantity Validation","text":"<p>Models with a <code>PydanticPintQuantity</code> annotated field can be constructed from string, dictionaries, or directly with pint quantities. The <code>PydanticPintQuantity</code> enforces a particular unit, but it can convert from any unit of the same quantity. For instance, <code>meters</code> are equivalent to <code>kilometers</code> and <code>watt * second / newton</code>.</p> <p>In the example below, all the following are equivalent.</p> From <code>str</code>From <code>dict</code>From <code>pint.Quantity</code> <pre><code>class Model(BaseModel):\n    quantity: Annotated[Quantity, PydanticPintQuantity(\"m\")]\n\nModel(quantity=\"1000m\")\nModel(quantity=\"1km\")\nModel(quantity=\"1000 W s N^-1\")\n</code></pre> <pre><code>class Model(BaseModel):\n    quantity: Annotated[Quantity, PydanticPintQuantity(\"m\")]\n\nModel(quantity={\"magnitude\": 1000, \"units\": \"m\"})\nModel(quantity={\"magnitude\": 1, \"units\": \"km\"})\nModel(quantity={\"magnitude\": 1000, \"units\": \"W s N^-1\"})\n</code></pre> <pre><code>class Model(BaseModel):\n    quantity: Annotated[Quantity, PydanticPintQuantity(\"m\")]\n\nureg = UnitRegistry()\n\nModel(quantity=1000 * ureg.meters)\nModel(quantity=1 * ureg.kilometers)\nModel(quantity=1000 * ureg.watts * ureg.seconds / ureg.newton)\n</code></pre>"},{"location":"usage/#validation-based-on-units-or-dimensions","title":"Validation Based on Units or Dimensions","text":"<p>The <code>PydanticPintQuantity</code> annotation allows for restrictions based on either units or dimensions. By default, it will try to automatically deduce the restriction type. To avoid automatic deduction, use <code>restriction=\"units\"</code> or <code>restriction=\"dimensions\"</code> to be specific.</p> <p>Restrictions on the unit requires all inputs to the field be convertible to the specified unit. The value the model stores has the units specified in the annotation. Restrictions on the dimensions only requires input values to be of the specified dimension. The units provided (units are required here) are kept. This means there is no common / default unit for that field.</p> Restricting UnitsRestricting Dimensions <pre><code>class Model(BaseModel):\n    # quantity must be convertible to a \"meter\" (and will be represented as meters)\n    quantity: Annotated[Quantity, PydanticPintQuantity(\"m\")]\n\nModel(quantity=1 * ureg.meters)\nModel(quantity=1 * ureg.inches)\n#&gt; Model(quantity=&lt;Quantity(1, 'meter')&gt;)\n#&gt; Model(quantity=&lt;Quantity(0.0254, 'meter')&gt;)\n</code></pre> <pre><code>class Model(BaseModel):\n    # quantity must have units that measure length (and will keep the units provided)\n    quantity: Annotated[Quantity, PydanticPintQuantity(\"[length]\")]\n\nModel(quantity=1 * ureg.meters)\nModel(quantity=1 * ureg.inches)\n#&gt; Model(quantity=&lt;Quantity(1, 'meter')&gt;)\n#&gt; Model(quantity=&lt;Quantity(1, 'inch')&gt;)\n</code></pre>"},{"location":"usage/#strict-mode","title":"Strict Mode","text":"<p>By default, strict mode is enabled which forces users to include units when instantiating the model. Only <code>str</code>s, <code>dict</code>s, and <code>pint.Quantity</code>s can be used to construct the field. If strict mode is disabled, then users may input a number (i.e. <code>numbers.Number</code>), and the serialization will use the units specified in the annotation.</p> Strict mode enabled (default)Strict mode disabled <pre><code>class Model(BaseModel):\n    quantity: Annotated[Quantity, PydanticPintQuantity(\"m\", strict=True)]\n\ntry:\n    print(Model(quantity=1))\nexcept ValidationError as e:\n    print(e)\n#&gt; 1 validation error for Model\n#&gt; quantity\n#&gt; Value error, unknown type [type=value_error, input_value='1', input_type=str]\n#&gt;     For further information visit https://errors.pydantic.dev/2.7/v/value_error\n</code></pre> <pre><code>class Model(BaseModel):\n    quantity: Annotated[Quantity, PydanticPintQuantity(\"m\", strict=False)]\n\ntry:\n    print(Model(quantity=1))\nexcept ValidationError as e:\n    print(e)\n#&gt; quantity=&lt;Quantity(1, 'meter')&gt;\n</code></pre>"},{"location":"usage/#value-restrictions-with-pydanticfield","title":"Value Restrictions with <code>pydantic.Field</code>","text":"<p>The <code>PydanticPintValue</code> class is a wrapper for a <code>pint.Quantity</code> instance. It adds methods to the <code>pint.Quantity</code> instance that allows Pydantic to interface with it. This in turn gives <code>pint.Quantity</code> the ability to be used within the field comparison restrictions. Note, the <code>Field</code> must be specified in as an annotation instead of assigned to the field.</p> <pre><code>ureg = pint.UnitRegistry()\n\nclass Model(BaseModel):\n    positive:     Annotated[Quantity, PydanticPintQuantity(\"m\", ureg=ureg), Field(gt=PydanticPintValue(0, \"m\", ureg=ureg))]\n    non_negative: Annotated[Quantity, PydanticPintQuantity(\"m\", ureg=ureg), Field(ge=PydanticPintValue(0, \"m\", ureg=ureg))]\n    negative:     Annotated[Quantity, PydanticPintQuantity(\"m\", ureg=ureg), Field(lt=PydanticPintValue(0, \"m\", ureg=ureg))]\n    non_positive: Annotated[Quantity, PydanticPintQuantity(\"m\", ureg=ureg), Field(le=PydanticPintValue(0, \"m\", ureg=ureg))]\n    even:         Annotated[Quantity, PydanticPintQuantity(\"m\", ureg=ureg), Field(multiple_of=PydanticPintValue(2, \"m\", ureg=ureg))]\n\nmodel = Model(\n    positive=\"1m\",\n    non_negative=\"0m\",\n    negative=\"-1m\",\n    non_positive=\"0m\",\n    even=\"2m\",\n)\n</code></pre>"},{"location":"usage/#custom-unit-registry-and-unit-registry-context","title":"Custom Unit Registry and Unit Registry Context","text":"<p>Developers can pass in a custom <code>pint.UnitRegistry</code> or a custom <code>pint.Context</code>s. This feature is useful if there is a pre-existing, custom unit registry already setup. Custom contexts can be enabled to use different transformation functions between dimensions. See pint documentation for more information.</p> <p>Multiple contexts</p> <p>All contexts specified will be added to the unit registry. They will all be used in the order specified when converting between two types.</p> <p>The following example sets up a context that converts between a quantity of length and a quantity of time.</p> Using a unit registryUsing a unit registry context <pre><code>ureg = pint.UnitRegistry()\nctx = pint.Context()\nctx.add_transformation(\"[length]\", \"[time]\", lambda ureg, x: x / (100 * ureg.miles) * (1.5 * ureg.hours))\nctx.add_transformation(\"[time]\", \"[length]\", lambda ureg, x: x / (1.5 * ureg.hours) * (100 * ureg.miles))\nureg.enable_context(ctx)\n\nclass Model(BaseModel):\n    quantity: Annotated[Quantity, PydanticPintQuantity(\"hr\", ureg=ureg)]\n\nprint(Model(quantity=\"100 mi\"))\n#&gt; quantity=&lt;Quantity(1.5, 'hour')&gt;\n</code></pre> <pre><code>ctx = pint.Context()\nctx.add_transformation(\"[length]\", \"[time]\", lambda ureg, x: x / (100 * ureg.miles) * (1.5 * ureg.hours))\nctx.add_transformation(\"[time]\", \"[length]\", lambda ureg, x: x / (1.5 * ureg.hours) * (100 * ureg.miles))\n\nclass Model(BaseModel):\n    quantity: Annotated[Quantity, PydanticPintQuantity(\"hr\", ureg_contexts=[ctx])]\n\nprint(Model(quantity=\"100 mi\"))\n#&gt; quantity=&lt;Quantity(1.5, 'hour')&gt;\n</code></pre>"},{"location":"usage/#modifying-unit-registry","title":"Modifying Unit Registry","text":"<p>An interesting side effect with specifying a unit registry is that it can be modified outside the model. For instance, a developer may set up a unit registry with a particular context enabled, but they can later (programmatically) disable it. This causes the validation for a model to change.</p> <pre><code>ureg = pint.UnitRegistry()\nctx = pint.Context()\nctx.add_transformation(\"[length]\", \"[time]\", lambda ureg, x: x / (100 * ureg.miles) * (1.5 * ureg.hours))\nctx.add_transformation(\"[time]\", \"[length]\", lambda ureg, x: x / (1.5 * ureg.hours) * (100 * ureg.miles))\n\nclass Model(BaseModel):\n    quantity: Annotated[Quantity, PydanticPintQuantity(\"m\", ureg=ureg)]\n\nwith ureg.context(ctx):\n    print(Model(quantity=\"100 mi\"))\n\ntry:\n    print(Model(quantity=\"100 mi\"))\nexcept ValidationError as e:\n    print(e)\n\n#&gt; quantity=&lt;Quantity(1.5, 'hour')&gt;\n#&gt; 1 validation error for Model\n#&gt; quantity\n#&gt;   Value error, Cannot convert from 'mile' ([length]) to 'hour' ([time]) [type=value_error, input_value='100 mi', input_type=str]\n#&gt;     For further information visit https://errors.pydantic.dev/2.7/v/value_error\n</code></pre> <p>Feature or Bug?</p> <p>Whether this is a feature or a bug is up for the developer to decide. It is clearly a feature of Pint However, Pydantic might consider this behavior a bug due to the validation schema changing over time.</p> <p>Consider using unit registry contexts instead. They are self contained to the field.</p>"},{"location":"usage/#quantity-serialization","title":"Quantity Serialization","text":"<p><code>PydanticPintQuantity</code> can be serialized in different ways, similar to the validation. The annotation can have a serialization mode for <code>\"str\"</code>, <code>\"dict\"</code>, <code>\"number\"</code> or <code>None</code> (the default). The default serialization behavior is to return a <code>str</code> or <code>pint.Quantity</code>, depending on the whether it produce a JSON serializable object. That is, it will return a <code>str</code> if in Pydantic's <code>\"json\"</code> mode, and it will return a <code>pint.Quantity</code> if in Pydantic's <code>\"python\"</code>. Use <code>to_json</code> to change between these modes if using the serialization function directly.</p> Default (<code>ser_mode=None</code>)To <code>str</code>To <code>dict</code>To <code>number</code> <pre><code>class Model(BaseModel):\n    quantity: Annotated[Quantity, PydanticPintQuantity(\"m\")]\n\nm = Model(quantity={\"magnitude\": 1000, \"units\": \"m\"})\n\nprint(m.model_dump())\nprint(m.model_dump(mode=\"json\"))\n#&gt; {'quantity': &lt;Quantity(1000, 'meter')&gt;}\n#&gt; {'quantity': '1000 meter'}\n</code></pre> <pre><code>class Model(BaseModel):\n    quantity: Annotated[Quantity, PydanticPintQuantity(\"m\", ser_mode=\"str\")]\n\nm = Model(quantity={\"magnitude\": 1000, \"units\": \"m\"})\n\nprint(m.model_dump())\nprint(m.model_dump(mode=\"json\"))\n#&gt; {'quantity': '1000 meter'}\n#&gt; {'quantity': '1000 meter'}\n</code></pre> <pre><code>class Model(BaseModel):\n    quantity: Annotated[Quantity, PydanticPintQuantity(\"m\", ser_mode=\"dict\")]\n\nm = Model(quantity={\"magnitude\": 1000, \"units\": \"m\"})\n\nprint(m.model_dump())\nprint(m.model_dump(mode=\"json\"))\n#&gt; {'quantity': {'magnitude': 1000, 'units': &lt;Unit('meter')&gt;}}\n#&gt; {'quantity': {'magnitude': 1000, 'units': 'meter'}}\n</code></pre> <pre><code>class Model(BaseModel):\n    quantity: Annotated[Quantity, PydanticPintQuantity(\"m\", ser_mode=\"number\")]\n\nm = Model(quantity={\"magnitude\": 1000, \"units\": \"m\"})\n\nprint(m.model_dump())\nprint(m.model_dump(mode=\"json\"))\n#&gt; {'quantity': 1000}\n#&gt; {'quantity': 1000}\n</code></pre> <p>Serializing to a Number</p> <p>Serialization to a number is dangerous due to the loss of information of the units. If you need to get the magnitude of the value, it is recommended to use <code>\"dict\"</code> for serialization mode instead. Users can pull the magnitude easily from the <code>\"magnitude\"</code> key.</p>"},{"location":"api/quantity/","title":"Quantity","text":""},{"location":"api/quantity/#pydantic_pint.quantity","title":"pydantic_pint.quantity","text":"<p>Defines the Pydantic <code>pint.Quantity</code>.</p>"},{"location":"api/quantity/#pydantic_pint.quantity.PydanticPintQuantity","title":"PydanticPintQuantity","text":"<pre><code>PydanticPintQuantity(_arg, /, *, ureg=None, ureg_contexts=None, restriction=None, ser_mode=None, strict=True, exact=False)\n</code></pre> <p>Pydantic Pint Quantity.</p> <p>Pydantic compatible annotation for validating and serializing <code>pint.Quantity</code> fields. Accepts units or dimensions as the restriction type for the field.</p> PARAMETER DESCRIPTION <code>_arg</code> <p>The base units or dimensions to check the Pydantic field. If the field is restricted by units, all input units must be convertible to these units. If the field is restricted by dimension, then any unit of that dimension is allowed.</p> <p> TYPE: <code>str | Mapping[str, int]</code> </p> <code>ureg</code> <p>A custom Pint unit registry. If not specified, the default unit registry from <code>pydantic_pint.registry.app_registry</code> is used. See <code>pydantic_pint.registry.get_registry</code> and <code>pydantic_pint.registry.set_registry</code>.</p> <p> TYPE: <code>UnitRegistry | None</code> DEFAULT: <code>None</code> </p> <code>ureg_contexts</code> <p>A custom Pint context (or context name) for the default unit registry. All contexts are applied in validation conversion.</p> <p> TYPE: <code>Iterable[str | Context] | None</code> DEFAULT: <code>None</code> </p> <code>restriction</code> <p>Identify what the argument is restricting, the units or dimensions. By default, it will automatically determine if the argument is specifying units or dimensions. It is recommended to use the default.</p> <p> TYPE: <code>Literal['units', 'dimensions'] | None</code> DEFAULT: <code>None</code> </p> <code>ser_mode</code> <p>The mode for serializing the field; either <code>\"str\"</code>, <code>\"dict\", \"number\"</code>. By default, in Pydantic's <code>\"python\"</code> serialization mode, fields are serialzied to a <code>pint.Quantity</code>; in Pydantic's <code>\"json\"</code> serialziation mode, fields are serialized to a <code>str</code>. Note, the units are dropped when serializing to a number.</p> <p> TYPE: <code>Literal['str', 'dict', 'number'] | None</code> DEFAULT: <code>None</code> </p> <code>strict</code> <p>Forces users to specify units; on by default. If disabled, a value without units - provided by the user - will be treated as the base units of the <code>PydanticPintQuantity</code>. Strict mode is ignored and always applied if specifying dimensionality (instead of units).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>exact</code> <p>Forces the units to be exact; off by default. If enabled, a value with units - provided by the user - must match the base units of the <code>PydanticPintQuantity</code>. Strict mode may be disabled as well, in which case, a value with no units will fall back to the base units. When restricting the dimensions, the user must match the base dimensions exactly, without using any custom transformations.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/pydantic_pint/quantity.py</code> <pre><code>def __init__(\n    self,\n    _arg: str | Mapping[str, int],\n    /,\n    *,\n    ureg: pint.UnitRegistry | None = None,\n    ureg_contexts: Iterable[str | pint.Context] | None = None,\n    restriction: Literal[\"units\", \"dimensions\"] | None = None,\n    ser_mode: Literal[\"str\", \"dict\", \"number\"] | None = None,\n    strict: bool = True,\n    exact: bool = False,\n):\n    self.restriction = restriction.lower() if restriction else None\n    self.ser_mode = ser_mode.lower() if ser_mode else None\n    self.strict = strict\n    self.exact = exact\n\n    self.ureg = ureg if ureg else get_registry()\n    self.ureg_contexts = ureg_contexts if ureg_contexts else []\n\n    # if restriction is not specified, try to automatically figure out what to restrict\n    # this is based on how `pint` can digest the `_arg`\n    # e.g. `PydanticPintQuantity(\"meter\")` -&gt; automatically parse as units\n    # e.g. `PydanticPintQuantity(\"[length]\")` -&gt; automatically parse as dimensions\n\n    _units = None\n    _dims = None\n\n    if self.restriction is None or self.restriction == \"units\":\n        try:\n            _units = self.ureg(_arg).units\n            _dims = _units.dimensionality\n            self.restriction = \"units\"\n        except AttributeError:\n            if self.restriction == \"units\":\n                raise\n\n    if self.restriction is None or self.restriction == \"dimensions\":\n        try:\n            _units = None\n            _dims = self.ureg.get_dimensionality(_arg)\n            self.restriction = \"dimensions\"\n        except ValueError:\n            if self.restriction == \"dimensions\":\n                raise\n\n    if self.restriction is None:\n        raise ValueError(f\"cannot deduce units or dimensions from '{_arg}'\")\n\n    self.units = _units\n    self.dimensions = _dims\n</code></pre>"},{"location":"api/quantity/#pydantic_pint.quantity.PydanticPintQuantity.validate","title":"validate","text":"<pre><code>validate(v, info=None)\n</code></pre> <p>Validate <code>PydanticPintQuantity</code>.</p> PARAMETER DESCRIPTION <code>v</code> <p>The quantity that should be validated.</p> <p> TYPE: <code>dict | str | Number | PlainQuantity</code> </p> <code>info</code> <p>The validation info provided by the Pydantic schema.</p> <p> TYPE: <code>ValidationInfo | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>PlainQuantity</code> <p>The validated <code>pint.Quantity</code> with the correct units.</p> RAISES DESCRIPTION <code>ValueError</code> <p>An error occurred validating the specified value. It is raised if any of the following occur.</p> <ul> <li>A <code>dict</code> is received and the keys <code>\"magnitude\"</code> and <code>\"units\"</code> do not exist.</li> <li>There are no units provided in strict mode.</li> <li>The units do not match in exact mode.</li> <li>The dimensions do not match in exact mode.</li> <li>Provided units cannot be converted to required units.</li> <li>Provided units cannot be converted to required dimensions.</li> <li>No such units found in registry.</li> <li>An unknown unit was provided.</li> <li>An unknown type for value was provided.</li> </ul> <code>TypeError</code> <p>An error occurred from unit registry or unit registry context. It is not propagated as a <code>pydantic.ValidationError</code> because it does not stem from a user error.</p> Source code in <code>src/pydantic_pint/quantity.py</code> <pre><code>def validate(\n    self,\n    v: dict | str | Number | Quantity,\n    info: core_schema.ValidationInfo | None = None,\n) -&gt; Quantity:\n    \"\"\"Validate `PydanticPintQuantity`.\n\n    Args:\n        v:\n            The quantity that should be validated.\n        info:\n            The validation info provided by the Pydantic schema.\n\n    Returns:\n        The validated `pint.Quantity` with the correct units.\n\n    Raises:\n        ValueError:\n            An error occurred validating the specified value.\n            It is raised if any of the following occur.\n\n            - A `dict` is received and the keys `\"magnitude\"` and `\"units\"` do not exist.\n            - There are no units provided in strict mode.\n            - The units do not match in exact mode.\n            - The dimensions do not match in exact mode.\n            - Provided units cannot be converted to required units.\n            - Provided units cannot be converted to required dimensions.\n            - No such units found in registry.\n            - An unknown unit was provided.\n            - An unknown type for value was provided.\n        TypeError:\n            An error occurred from unit registry or unit registry context.\n            It is not propagated as a `pydantic.ValidationError` because it does not stem from a user error.\n    \"\"\"\n    try:\n        if isinstance(v, dict):\n            v = f\"{v['magnitude']} {v.get('units', '')}\"\n    except KeyError as e:\n        raise ValueError(\"no `magnitude` or `units` keys found\") from e\n\n    try:\n        if isinstance(v, str):\n            # relies on ureg to return a number if no units are present\n            # if value is a quantity, then units are present and check on the units being convertible\n            # if value is a number, then check on strict mode will happen next\n            v = self.ureg(v)\n    except pint.UndefinedUnitError as e:\n        raise ValueError(e) from e\n\n    try:\n        if self.restriction == \"units\":\n            return self._validate_units(v)\n        elif self.restriction == \"dimensions\":\n            return self._validate_dimensions(v)\n        else:\n            raise ValueError(f\"unknown restrictions '{self.restriction}'\")\n    except AttributeError as e:\n        # raises attribute error if value is a number\n        # this case only happes when parsing from a string, the units are not present, and not in strict mode\n        # see comments above related to ureg returning a number\n        raise ValueError(\"no units found\") from e\n    except pint.DimensionalityError as e:\n        raise ValueError(e) from e\n    except KeyError as e:\n        # this should not be considered a validation error\n        # raising a type error with extra information\n        raise TypeError(f\"unknown unit registry context {e}\") from e\n\n    raise ValueError(f\"unknown error: {v=} | {type(v)=}\")\n</code></pre>"},{"location":"api/quantity/#pydantic_pint.quantity.PydanticPintQuantity.serialize","title":"serialize","text":"<pre><code>serialize(v, info=None, *, to_json=False)\n</code></pre> <p>Serialize <code>PydanticPintQuantity</code>.</p> PARAMETER DESCRIPTION <code>v</code> <p>The quantity that should be serialized.</p> <p> TYPE: <code>PlainQuantity</code> </p> <code>info</code> <p>The serialization info provided by the Pydantic schema.</p> <p> TYPE: <code>SerializationInfo | None</code> DEFAULT: <code>None</code> </p> <code>to_json</code> <p>Whether or not to serialize to a json convertible object. Useful if using <code>PydantiPintQuantity</code> as a utility outside of Pydantic models.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>dict | str | PlainQuantity</code> <p>The serialized <code>pint.Quantity</code>.</p> Source code in <code>src/pydantic_pint/quantity.py</code> <pre><code>def serialize(\n    self,\n    v: Quantity,\n    info: core_schema.SerializationInfo | None = None,\n    *,\n    to_json: bool = False,\n) -&gt; dict | str | Quantity:\n    \"\"\"Serialize `PydanticPintQuantity`.\n\n    Args:\n        v:\n            The quantity that should be serialized.\n        info:\n            The serialization info provided by the Pydantic schema.\n        to_json:\n            Whether or not to serialize to a json convertible object.\n            Useful if using `PydantiPintQuantity` as a utility outside of Pydantic models.\n\n    Returns:\n        The serialized `pint.Quantity`.\n    \"\"\"\n    to_json = to_json or (info and info.mode_is_json())\n\n    if self.ser_mode == \"dict\":\n        return {\n            \"magnitude\": v.magnitude,\n            \"units\": v.units if not to_json else f\"{v.units}\",\n        }\n\n    if self.ser_mode == \"number\":\n        return v.magnitude\n\n    # special case when no serialization mode is specified, but\n    # need to serialize to a json convertible object\n    if self.ser_mode == \"str\" or to_json:\n        return f\"{v}\"\n\n    # return the `pint.Quanity` object as is (no serialization)\n    return v\n</code></pre>"},{"location":"api/quantity/#pydantic_pint.quantity.PydanticPintQuantity.__get_pydantic_core_schema__","title":"__get_pydantic_core_schema__","text":"<pre><code>__get_pydantic_core_schema__(source_type, handler)\n</code></pre> <p>Gets the Pydantic core schema.</p> PARAMETER DESCRIPTION <code>source_type</code> <p>The source type.</p> <p> TYPE: <code>Any</code> </p> <code>handler</code> <p>The <code>GetCoreSchemaHandler</code> instance.</p> <p> TYPE: <code>GetCoreSchemaHandler</code> </p> RETURNS DESCRIPTION <code>CoreSchema</code> <p>The Pydantic core schema.</p> Source code in <code>src/pydantic_pint/quantity.py</code> <pre><code>def __get_pydantic_core_schema__(\n    self,\n    source_type: Any,\n    handler: GetCoreSchemaHandler,\n) -&gt; core_schema.CoreSchema:\n    \"\"\"Gets the Pydantic core schema.\n\n    Args:\n        source_type:\n            The source type.\n        handler:\n            The `GetCoreSchemaHandler` instance.\n\n    Returns:\n        The Pydantic core schema.\n    \"\"\"\n    _from_typedict_schema = {\n        \"magnitude\": core_schema.typed_dict_field(\n            core_schema.str_schema(coerce_numbers_to_str=True),\n        ),\n        \"units\": core_schema.typed_dict_field(\n            core_schema.str_schema(),\n            required=False,\n        ),\n    }\n\n    validate_schema = core_schema.chain_schema(\n        [\n            core_schema.union_schema(\n                [\n                    core_schema.is_instance_schema(Quantity),\n                    core_schema.str_schema(coerce_numbers_to_str=True),\n                    core_schema.typed_dict_schema(_from_typedict_schema),\n                ]\n            ),\n            core_schema.with_info_plain_validator_function(self.validate),\n        ]\n    )\n\n    validate_json_schema = core_schema.chain_schema(\n        [\n            core_schema.union_schema(\n                [\n                    core_schema.str_schema(coerce_numbers_to_str=True),\n                    core_schema.typed_dict_schema(_from_typedict_schema),\n                ]\n            ),\n            core_schema.no_info_plain_validator_function(self.validate),\n        ]\n    )\n\n    serialize_schema = core_schema.plain_serializer_function_ser_schema(\n        self.serialize,\n        info_arg=True,\n    )\n\n    return core_schema.json_or_python_schema(\n        json_schema=validate_json_schema,\n        python_schema=validate_schema,\n        serialization=serialize_schema,\n    )\n</code></pre>"},{"location":"api/registry/","title":"Registry","text":""},{"location":"api/registry/#pydantic_pint.registry","title":"pydantic_pint.registry","text":"<p>Defines the global unit registry for <code>PydanticPintQuantity</code>.</p>"},{"location":"api/registry/#pydantic_pint.registry.app_registry","title":"app_registry  <code>module-attribute</code>","text":"<pre><code>app_registry = ApplicationRegistry(_DEFAULT_REGISTRY)\n</code></pre> <p>Pydantic Pint default application registry.</p>"},{"location":"api/registry/#pydantic_pint.registry.get_registry","title":"get_registry","text":"<pre><code>get_registry()\n</code></pre> <p>Get the Pydantic Pint global registry.</p> RETURNS DESCRIPTION <code>UnitRegistry</code> <p>The current global registry.</p> Source code in <code>src/pydantic_pint/registry.py</code> <pre><code>def get_registry() -&gt; pint.UnitRegistry:\n    \"\"\"Get the Pydantic Pint global registry.\n\n    Returns:\n        The current global registry.\n    \"\"\"\n    return app_registry.get()\n</code></pre>"},{"location":"api/registry/#pydantic_pint.registry.set_registry","title":"set_registry","text":"<pre><code>set_registry(registry)\n</code></pre> <p>Set the Pydantic Pint global registry.</p> PARAMETER DESCRIPTION <code>registry</code> <p>The new global registry.</p> <p> TYPE: <code>UnitRegistry</code> </p> Source code in <code>src/pydantic_pint/registry.py</code> <pre><code>def set_registry(registry: pint.UnitRegistry):\n    \"\"\"Set the Pydantic Pint global registry.\n\n    Args:\n        registry: The new global registry.\n    \"\"\"\n    app_registry.set(registry)\n</code></pre>"},{"location":"api/value/","title":"Value","text":""},{"location":"api/value/#pydantic_pint.value","title":"pydantic_pint.value","text":"<p>Defines the Pydantic compatible wrapper for an instance of <code>pint.Quantity</code>.</p>"},{"location":"api/value/#pydantic_pint.value.PydanticPintValue","title":"PydanticPintValue","text":"<p>Proxy class for a Pint Quantity instance with pydantic serialization.</p> <p>Unlink <code>PydanticPintQuantity</code>, <code>PydanticPintValue</code> wraps an instance of a pint quantity. Methods are added to allow it to interact with pydantic, e.g. serialization. The class immediately resolves to a <code>pint.Quantity</code> upon construction. The primary use for <code>PydanticPintValue</code> is in <code>pydantic.Field</code> comparison restrictions.</p>"},{"location":"api/value/#pydantic_pint.value.PydanticPintValue.__new__","title":"__new__","text":"<pre><code>__new__(__value, __units=None, /, *, ureg=None)\n</code></pre> <p>Coarse value into a <code>pint.Quantity</code> based on provided unit registry.</p> PARAMETER DESCRIPTION <code>__value</code> <p>The magnitude of the quantity.</p> <p> TYPE: <code>Number</code> </p> <code>__units</code> <p>The units of the quantity. Defaults to unitless quantity.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>ureg</code> <p>The unit registry from which to create the quantity. Defaults to <code>pydantic_pint.app_registry</code>.</p> <p> TYPE: <code>UnitRegistry | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Quantity</code> <p>A <code>pint.Quantity</code> with pydantic serialization.</p> Source code in <code>src/pydantic_pint/value.py</code> <pre><code>def __new__(\n    cls,\n    __value: Number,\n    __units: str | None = None,\n    /,\n    *,\n    ureg: pint.UnitRegistry | None = None,\n) -&gt; pint.Quantity:\n    \"\"\"Coarse value into a `pint.Quantity` based on provided unit registry.\n\n    Args:\n        __value (Number):\n            The magnitude of the quantity.\n        __units (str | None, optional):\n            The units of the quantity.\n            Defaults to unitless quantity.\n        ureg (pint.UnitRegistry | None, optional):\n            The unit registry from which to create the quantity.\n            Defaults to `pydantic_pint.app_registry`.\n\n    Returns:\n        A `pint.Quantity` with pydantic serialization.\n    \"\"\"\n    ureg = ureg if ureg else get_registry()\n    inst = ureg.Quantity(__value, __units)\n\n    inst.__pydantic_serializer__ = SchemaSerializer(\n        core_schema.any_schema(\n            serialization=core_schema.plain_serializer_function_ser_schema(\n                lambda v: str(v),\n                info_arg=False,\n                when_used=\"always\",\n            )\n        )\n    )\n\n    return inst\n</code></pre>"}]}