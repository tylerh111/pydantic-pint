{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Pydantic Pint","text":"<p>Pydantic is a Python library for data validation and data serialization. Pint is a Python library for defining, operating, and manipulating physical quantities. By default, they do not play well with each other.</p> <p>Many projects that have a need for data validation may also need to work with physical quantities. Pydantic Pint aims to bridge that gap by providing Pydantic validation for Pint quantities.</p> <pre><code>from pydantic import BaseModel\nfrom pydantic_pint import PydanticPintQuantity\nfrom pint import Quantity\nfrom typing import Annotations\n\nclass Box(BaseModel):\n    length: Annotated[Quantity, PydanticPintQuantity(\"m\")]\n    width: Annotated[Quantity, PydanticPintQuantity(\"m\")]\n\nbox = Box(\n    length=\"4m\",\n    width=\"2m\",\n)\n</code></pre>"},{"location":"#getting-started","title":"Getting Started","text":""},{"location":"#installation","title":"Installation","text":"<p>Pydantic Pint is available as <code>pydantic-pint</code> on PyPI.</p> <p>Pydantic Pint requires both Pydantic and Pint to be installed. It also requires <code>typing.Annotated</code> (for older version of python use <code>typing_extensions</code>).</p> <pre><code>pip install pydantic-pint\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>Pydantic Pint provides <code>PydanticPintQuantity</code> which enabled Pydantic validation for Pint quantities. For a field of a Pydantic model to have quantity validation, it must be annotated with a <code>PydanticPintQuantity</code> for a given unit.</p> <pre><code>from pydantic import BaseModel\nfrom pydantic_pint import PydanticPintQuantity\nfrom pint import Quantity\nfrom typing import Annotated\n\nclass Coordinates(BaseModel):\n    latitude: Annotated[Quantity, PydanticPintQuantity(\"deg\")]\n    longitude: Annotated[Quantity, PydanticPintQuantity(\"deg\")]\n    altitude: Annotated[Quantity, PydanticPintQuantity(\"km\")]\n</code></pre> <p>Users of the model can input anything to the field with a specified unit that is convertible to the units declared in the annotation. For instance, the units for <code>Coordinates.altitude</code> are kilometers, however users can specify meters instead. <code>PydanticPintQuantity</code> will handle the conversion from meters to kilometers.</p> <pre><code>coord = Coordinates(\n    latitude=\"39.905705 deg\",\n    longitude=\"-75.166519 deg\",\n    altitude=\"12 meters\",\n)\n\nprint(coord)\n#&gt; latitude=&lt;Quantity(39.905705, 'degree')&gt; longitude=&lt;Quantity(-75.166519, 'degree')&gt; altitude=&lt;Quantity(0.012, 'kilometer')&gt;\nprint(f\"{coord!r}\")\n#&gt; Coordinates(latitude=&lt;Quantity(39.905705, 'degree')&gt;, longitude=&lt;Quantity(-75.166519, 'degree')&gt;, altitude=&lt;Quantity(0.012, 'kilometer')&gt;)\nprint(coord.model_dump())\n#&gt; {'latitude': &lt;Quantity(39.905705, 'degree')&gt;, 'longitude': &lt;Quantity(-75.166519, 'degree')&gt;, 'altitude': &lt;Quantity(0.012, 'kilometer')&gt;}\nprint(coord.model_dump(mode=\"json\"))\n#&gt; {'latitude': '39.905705 degree', 'longitude': '-75.166519 degree', 'altitude': '0.012 kilometer'}\nprint(f\"{coord.model_dump_json()!r}\")\n#&gt; '{\"latitude\":\"39.905705 degree\",\"longitude\":\"-75.166519 degree\",\"altitude\":\"0.012 kilometer\"}'\n</code></pre>"},{"location":"changes/","title":"Changes","text":"<p>All notable changes to this project will be documented in this file.</p>"},{"location":"changes/#unreleased","title":"Unreleased","text":""},{"location":"changes/#01---2024-05-06","title":"0.1 - 2024-05-06","text":""},{"location":"changes/#features","title":"Features","text":"<ul> <li>Added initial code, docs, and tools.</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>Thank you for taking the time to contribute to Pydantic Pint! All types of contributions are encouraged and valued. Please refer to this page for ways to contribute.</p>"},{"location":"contributing/#overview","title":"Overview","text":"<p>There are plenty of ways to support the project and show your appreciation!</p> <ul> <li>Create and comment on issues.</li> <li>Create and comment on pull requests.</li> <li>Fork the project.</li> <li>Star the project.</li> <li>Watch the project.</li> <li>Talk about the project!</li> </ul>"},{"location":"contributing/#creating-issues","title":"Creating Issues","text":"<p>GitHub issues track any enhancements, bugs, questions, or suggestions for this project.</p> <ul> <li>Open an issue.</li> <li>Provide as much detail as you can.</li> <li>Provide project and platform version (python, pydantic, pint, etc.).</li> </ul>"},{"location":"contributing/#asking-questions","title":"Asking Questions","text":"<p>If you have a question, create an issue with the <code>question</code> label. We will try to answer it as best we can.</p> <p>Provide the following information when asking questions.</p> <ul> <li>Ask the question in a clear and concise manner.</li> <li>Search and link relevant issues and pull requests.</li> <li>Provide details and context separate from the question.   In other words, the question and context should be separate.   This makes it easier to answer the question if it is clearly stated.   Anything passed that can be a discussion.</li> </ul>"},{"location":"contributing/#requesting-features","title":"Requesting Features","text":"<p>If you have an idea for enhancements, open an issue with the <code>enhancement</code> label. We will determine if such an enhancement is worth implementing. Enhancements should improve the use of the project without breaking the existing functionality.</p> <p>Provide the following information when requesting features.</p> <ul> <li>Explain what currently does not exist with the project.</li> <li>Explain how the feature request can address the issue.</li> <li>Include usecases for the feature.</li> <li>Include examples for using the feature.</li> </ul>"},{"location":"contributing/#reporting-bugs","title":"Reporting Bugs","text":"<p>If you find a bug, open an issue with the <code>bug</code> label. Bug reports should contain information about the environment in which you are running. This is key in order to replicate the issue to further investigate and fix it.</p> <p>Provide the following information when reporting a bug.</p> <ul> <li>Environment, including project and platform information (python, pydantic, pint, etc.).</li> <li>Current behavior, include examples for replication.</li> <li>Expected behavior, include examples for verification.</li> </ul>"},{"location":"contributing/#updating-documentation","title":"Updating Documentation","text":"<p>If you think the documentation should be updated, open an issue with the <code>documentation</code> label. Documentation might have small issues that need fixed, e.g. misspellings or grammar mistakes, or might be related to enhancements or bugs, e.g. new or changed functionality.</p> <p>Provide the following information when updating the documentation.</p> <ul> <li>The documentation page that should be added.</li> <li>The documentation page that should be modified.</li> <li>The documentation page that should be removed.</li> <li>Updates to examples.</li> </ul>"},{"location":"contributing/#creating-pull-requests","title":"Creating Pull Requests","text":"<p>GitHub pull requests address the issues of the project.</p> <ul> <li>Fork the project.</li> <li>Create a branch from the latest revision on <code>main</code>.</li> <li>Implement the changes to address a particular issue(s).</li> <li>Open a pull request.</li> <li>Add the issue number to the description of the pull request.   It should be clear which issue (or issues) are addressed.</li> </ul>"},{"location":"contributing/#fixing-bugs","title":"Fixing Bugs","text":"<p>Fixing a bug should have an associated issue labeled as a <code>bug</code>. Make sure the bug is fixed correctly and completely. The following additions to your bugfix could help improve it.</p> <ul> <li>Add unit tests to cover the bugfix.   This ensures that it never pops back up.</li> <li>Test all facets of your changes so that no other parts of the code base breaks.   Check how the new feature interacts with other features.</li> <li>Make sure each commit is deliberate and meaningful.   Changes like spacing, formatting, or typos (in unrelated locations) are not necessary to change while implementing a feature or bugfix.   Ensure other parts of the code have not been modified that do not need to be modified to implement your feature or bugfix.</li> <li>Limit the size of your changes.   Large diffs can be difficult to verify and validate.</li> </ul>"},{"location":"contributing/#implementing-features","title":"Implementing Features","text":"<p>Implementing a feature should have an associated issue labeled as an <code>enhancement</code>. Make sure the feature is implemented correctly and completely. The following additions to your feature could help improve it.</p> <ul> <li>Add documentation.</li> <li>Add unit tests.   Check corner cases, and how the feature works with bad or invalid input.</li> <li>Test all facets of your changes so that no other parts of the code base breaks.   Check how the new feature interacts with other features.</li> <li>Make sure each commit is deliberate and meaningful.   Changes like spacing, formatting, or typos (in unrelated locations) are not necessary to change while implementing a feature or bugfix.   Ensure other parts of the code have not been modified that do not need to be modified to implement your feature or bugfix.</li> <li>Limit the size of your changes.   Large diffs can be difficult to verify and validate.</li> </ul>"},{"location":"contributing/#thank-you","title":"Thank You!","text":"<p>You are help Pydantic Pint grow and prosper with your involvement. We hope to see your contributions in the project soon!</p>"},{"location":"license/","title":"License","text":"<p>MIT License</p> <p>Copyright \u00a9 2024 Tyler Hughes</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#quantity-validation","title":"Quantity Validation","text":"<p>Models with a <code>PydanticPintQuantity</code> annotated field can be constructed from string, dictionaries, or directly with pint quantities. The <code>PydanticPintQuantity</code> enforces a particular unit, but it can convert from any unit of the same quantity. For instance, <code>meters</code> are equivalent to <code>kilometers</code> and <code>watt * second / newton</code>.</p> <p>In the example below, all the following are equivalent.</p> From <code>str</code>From <code>dict</code>From <code>pint.Quantity</code> <pre><code>class Model(BaseModel):\n    quantity: Annotated[Quantity, PydanticPintQuantity(\"m\")]\n\nModel(quantity=\"1000m\")\nModel(quantity=\"1km\")\nModel(quantity=\"1000 W s N^-1\")\n</code></pre> <pre><code>class Model(BaseModel):\n    quantity: Annotated[Quantity, PydanticPintQuantity(\"m\")]\n\nModel(quantity={\"magnitude\": 1000, \"units\": \"m\"})\nModel(quantity={\"magnitude\": 1, \"units\": \"km\"})\nModel(quantity={\"magnitude\": 1000, \"units\": \"W s N^-1\"})\n</code></pre> <pre><code>class Model(BaseModel):\n    quantity: Annotated[Quantity, PydanticPintQuantity(\"m\")]\n\nureg = UnitRegistry()\n\nModel(quantity=1000 * ureg.meters)\nModel(quantity=1 * ureg.kilometers)\nModel(quantity=1000 * ureg.watts * ureg.seconds / ureg.newton)\n</code></pre>"},{"location":"usage/#strict-mode","title":"Strict Mode","text":"<p>By default, strict mode is enabled which forces users to include units when instantiating the model. Only <code>str</code>s, <code>dict</code>s, and <code>pint.Quantity</code>s can be used to construct the field. If strict mode is disabled, then users may input a number (i.e. <code>numbers.Number</code>), and the serialization will use the units specified in the annotation.</p> Strict mode enabled (default)Strict mode disabled <pre><code>class Model(BaseModel):\n    quantity: Annotated[Quantity, PydanticPintQuantity(\"m\", strict=True)]\n\ntry:\n    print(Model(quantity=1))\nexcept ValidationError as e:\n    print(e)\n#&gt; 1 validation error for Model\n#&gt; quantity\n#&gt; Value error, unknown type [type=value_error, input_value='1', input_type=str]\n#&gt;     For further information visit https://errors.pydantic.dev/2.7/v/value_error\n</code></pre> <pre><code>class Model(BaseModel):\n    quantity: Annotated[Quantity, PydanticPintQuantity(\"m\", strict=False)]\n\ntry:\n    print(Model(quantity=1))\nexcept ValidationError as e:\n    print(e)\n#&gt; quantity=&lt;Quantity(1, 'meter')&gt;\n</code></pre>"},{"location":"usage/#custom-unit-registry-and-unit-registry-context","title":"Custom Unit Registry and Unit Registry Context","text":"<p>Developers can pass in a custom <code>pint.UnitRegistry</code> or a custom <code>pint.Context</code>s. This feature is useful if there is a pre-existing, custom unit registry already setup. Custom contexts can be enabled to use different transformation functions between dimensions. See pint documentation for more information.</p> <p>Multiple contexts</p> <p>All contexts specified will be added to the unit registry. They will all be used in the order specified when converting between two types.</p> <p>The following example sets up a context that converts between a quantity of length and a quantity of time.</p> Using a unit registryUsing a unit registry context <pre><code>ureg = pint.UnitRegistry()\nctx = pint.Context()\nctx.add_transformation(\"[length]\", \"[time]\", lambda ureg, x: x / (100 * ureg.miles) * (1.5 * ureg.hours))\nctx.add_transformation(\"[time]\", \"[length]\", lambda ureg, x: x / (1.5 * ureg.hours) * (100 * ureg.miles))\nureg.enable_context(ctx)\n\nclass Model(BaseModel):\n    quantity: Annotated[Quantity, PydanticPintQuantity(\"hr\", ureg=ureg)]\n\nprint(Model(quantity=\"100 mi\"))\n#&gt; quantity=&lt;Quantity(1.5, 'hour')&gt;\n</code></pre> <pre><code>ctx = pint.Context()\nctx.add_transformation(\"[length]\", \"[time]\", lambda ureg, x: x / (100 * ureg.miles) * (1.5 * ureg.hours))\nctx.add_transformation(\"[time]\", \"[length]\", lambda ureg, x: x / (1.5 * ureg.hours) * (100 * ureg.miles))\n\nclass Model(BaseModel):\n    quantity: Annotated[Quantity, PydanticPintQuantity(\"hr\", ureg_contexts=[ctx])]\n\nprint(Model(quantity=\"100 mi\"))\n#&gt; quantity=&lt;Quantity(1.5, 'hour')&gt;\n</code></pre>"},{"location":"usage/#modifying-unit-registry","title":"Modifying Unit Registry","text":"<p>An interesting side effect with specifying a unit registry is that it can be modified outside the model. For instance, a developer may set up a unit registry with a particular context enabled, but they can later (programmatically) disable it. This causes the validation for a model to change.</p> <pre><code>ureg = pint.UnitRegistry()\nctx = pint.Context()\nctx.add_transformation(\"[length]\", \"[time]\", lambda ureg, x: x / (100 * ureg.miles) * (1.5 * ureg.hours))\nctx.add_transformation(\"[time]\", \"[length]\", lambda ureg, x: x / (1.5 * ureg.hours) * (100 * ureg.miles))\n\nclass Model(BaseModel):\n    quantity: Annotated[Quantity, PydanticPintQuantity(\"m\", ureg=ureg)]\n\nwith ureg.context(ctx):\n    print(Model(quantity=\"100 mi\"))\n\ntry:\n    print(Model(quantity=\"100 mi\"))\nexcept ValidationError as e:\n    print(e)\n\n#&gt; quantity=&lt;Quantity(1.5, 'hour')&gt;\n#&gt; 1 validation error for Model\n#&gt; quantity\n#&gt;   Value error, Cannot convert from 'mile' ([length]) to 'hour' ([time]) [type=value_error, input_value='100 mi', input_type=str]\n#&gt;     For further information visit https://errors.pydantic.dev/2.7/v/value_error\n</code></pre> <p>Feature or Bug?</p> <p>Whether this is a feature or a bug is up for the developer to decide. It is clearly a feature of Pint However, Pydantic might consider this behavior a bug due to the validation schema changing over time.</p> <p>Consider using unit registry contexts instead. They are self contained to the field.</p>"},{"location":"usage/#quantity-serialization","title":"Quantity Serialization","text":"<p><code>PydanticPintQuantity</code> can be serialized in different ways, similar to the validation. The annotation can have a serialization mode for <code>\"str\"</code>, <code>\"dict\"</code>, or <code>None</code> (the default). The default serialization behavior is to return a <code>str</code> or <code>pint.Quantity</code>, depending on the whether it produce a JSON serializable object. That is, it will return a <code>str</code> if in Pydantic's <code>\"json\"</code> mode, and it will return a <code>pint.Quantity</code> if in Pydantic's <code>\"python\"</code>. Use <code>to_json</code> to change between these modes if using the serialization function directly.</p> Default (<code>ser_mode=None</code>)To <code>str</code>To <code>dict</code> <pre><code>class Model(BaseModel):\n    quantity: Annotated[Quantity, PydanticPintQuantity(\"m\")]\n\nm = Model(quantity={\"magnitude\": 1000, \"units\": \"m\"})\n\nprint(m.model_dump())\nprint(m.model_dump(mode=\"json\"))\n#&gt; {'quantity': &lt;Quantity(1, 'meter')&gt;}\n#&gt; {'quantity': '1 meter'}\n</code></pre> <pre><code>class Model(BaseModel):\n    quantity: Annotated[Quantity, PydanticPintQuantity(\"m\", ser_mode=\"str\")]\n\nm = Model(quantity={\"magnitude\": 1000, \"units\": \"m\"})\n\nprint(m.model_dump())\nprint(m.model_dump(mode=\"json\"))\n#&gt; {'quantity': '1 meter'}\n#&gt; {'quantity': '1 meter'}\n</code></pre> <pre><code>class Model(BaseModel):\n    quantity: Annotated[Quantity, PydanticPintQuantity(\"m\", ser_mode=\"dict\")]\n\nm = Model(quantity={\"magnitude\": 1000, \"units\": \"m\"})\n\nprint(m.model_dump())\nprint(m.model_dump(mode=\"json\"))\n#&gt; {'quantity': {'magnitude': 1, 'units': &lt;Unit('meter')&gt;}}\n#&gt; {'quantity': {'magnitude': 1, 'units': 'meter'}}\n</code></pre> <p>Serializing to a Number</p> <p>Serialization to a number is not permitted due to the loss of information of the units. If you need to get the magnitude of the value, use <code>\"dict\"</code> mode instead for serialization. Users can pull the magnitude easily from the <code>\"magnitude\"</code> key.</p> <pre><code>class Model(BaseModel):\n    quantity: Annotated[Quantity, PydanticPintQuantity(\"m\", ser_mode=\"dict\")]\n\nm = Model(quantity={\"magnitude\": 1000, \"units\": \"m\"})\nprint(m.model_dump()[\"magnitude\"])\n</code></pre>"},{"location":"api/quantity/","title":"Quantity","text":""},{"location":"api/quantity/#pydantic_pint.quantity","title":"pydantic_pint.quantity","text":"<p>Defines the Pydantic <code>pint.Quantity</code>.</p>"},{"location":"api/quantity/#pydantic_pint.quantity.PydanticPintQuantity","title":"PydanticPintQuantity","text":"<pre><code>PydanticPintQuantity(units, *, ureg=None, ureg_contexts=None, ser_mode=None, strict=True)\n</code></pre> <p>Pydantic Pint Quantity.</p> <p>Pydantic compatible annotation for validating and serializing <code>pint.Quantity</code> fields.</p> PARAMETER DESCRIPTION <code>units</code> <p>The base units of the Pydantic field. All input units must be convertible to these units.</p> <p> TYPE: <code>str</code> </p> <code>ureg</code> <p>A custom Pint unit registry.</p> <p> TYPE: <code>UnitRegistry | None</code> DEFAULT: <code>None</code> </p> <code>ureg_contexts</code> <p>A custom Pint context (or context name) for the default unit registry. All contexts are applied in validation conversion.</p> <p> TYPE: <code>Iterable[str | Context] | None</code> DEFAULT: <code>None</code> </p> <code>ser_mode</code> <p>The mode for serializing the field; either <code>\"str\"</code> or <code>\"dict\"</code>. By default, in Pydantic's <code>\"python\"</code> serialization mode, fields are serialzied to a <code>pint.Quantity</code>; in Pydantic's <code>\"json\"</code> serialziation mode, fields are serialized to a <code>str</code>.</p> <p> TYPE: <code>Literal['str', 'dict'] | None</code> DEFAULT: <code>None</code> </p> <code>strict</code> <p>Forces users to specify units; on by default. If disabled, a value without units - provided by the user - will be treated as the base units of the <code>PydanticPintQuantity</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/pydantic_pint/quantity.py</code> <pre><code>def __init__(\n    self,\n    units: str,\n    *,\n    ureg: pint.UnitRegistry | None = None,\n    ureg_contexts: Iterable[str | pint.Context] | None = None,\n    ser_mode: Literal[\"str\", \"dict\"] | None = None,\n    strict: bool = True,\n):\n    self.ser_mode = ser_mode.lower() if ser_mode else None\n    self.strict = strict\n\n    self.ureg = ureg if ureg else pint.UnitRegistry()\n    self.ureg_contexts = ureg_contexts if ureg_contexts else []\n\n    self.units = self.ureg(units)\n</code></pre>"},{"location":"api/quantity/#pydantic_pint.quantity.PydanticPintQuantity.validate","title":"validate","text":"<pre><code>validate(v, info=None)\n</code></pre> <p>Validate <code>PydanticPintQuantity</code>.</p> PARAMETER DESCRIPTION <code>v</code> <p>The quantity that should be validated.</p> <p> TYPE: <code>dict | str | Number | PlainQuantity</code> </p> <code>info</code> <p>The validation info provided by the Pydantic schema.</p> <p> TYPE: <code>ValidationInfo | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>PlainQuantity</code> <p>The validated <code>pint.Quantity</code> with the correct units.</p> RAISES DESCRIPTION <code>ValueError</code> <p>An error occurred validating the specified value. It is raised if any of the following occur.</p> <ul> <li>A <code>dict</code> is received and the keys <code>\"magnitude\"</code> and <code>\"units\"</code> do not exist.</li> <li>There are no units provided in strict mode.</li> <li>Provided units cannot be converted to base units.</li> <li>An unknown unit was provided.</li> <li>An unknown type for value was provided.</li> </ul> <code>TypeError</code> <p>An error occurred from unit registry or unit registry context. It is not propagated as a <code>pydantic.ValidationError</code> because it does not stem from a user error.</p> Source code in <code>src/pydantic_pint/quantity.py</code> <pre><code>def validate(\n    self,\n    v: dict | str | Number | Quantity,\n    info: core_schema.ValidationInfo | None = None,\n) -&gt; Quantity:\n    \"\"\"Validate `PydanticPintQuantity`.\n\n    Args:\n        v:\n            The quantity that should be validated.\n        info:\n            The validation info provided by the Pydantic schema.\n\n    Returns:\n        The validated `pint.Quantity` with the correct units.\n\n    Raises:\n        ValueError:\n            An error occurred validating the specified value.\n            It is raised if any of the following occur.\n\n            - A `dict` is received and the keys `\"magnitude\"` and `\"units\"` do not exist.\n            - There are no units provided in strict mode.\n            - Provided units cannot be converted to base units.\n            - An unknown unit was provided.\n            - An unknown type for value was provided.\n        TypeError:\n            An error occurred from unit registry or unit registry context.\n            It is not propagated as a `pydantic.ValidationError` because it does not stem from a user error.\n    \"\"\"\n    try:\n        if isinstance(v, dict):\n            v = f\"{v['magnitude']} {v.get('units', '')}\"\n    except KeyError as e:\n        raise ValueError(\"no `magnitude` or `units` keys found\") from e\n\n    try:\n        if isinstance(v, str):\n            # relies on ureg to return a number if no units are present\n            # if value is a quantity, then units are present and check on the units being convertible\n            # if value is a number, then check on strict mode will happen next\n            v = self.ureg(v)\n    except pint.UndefinedUnitError as e:\n        raise ValueError(e) from e\n\n    try:\n        if isinstance(v, Number) and not self.strict:\n            # check must happen after conversion from string because string might not have any units\n            # only applicable if dealing with no units and if in strict mode\n            v = v * self.units\n        if isinstance(v, Quantity):\n            v = v.to(self.units, *self.ureg_contexts)\n            return v\n    except AttributeError as e:\n        # raises attribute error if value is a number\n        # this case only happes when parsing from a string, the units are not present, and not in strict mode\n        # see comments above related to ureg returning a number\n        raise ValueError(\"no units found\") from e\n    except pint.DimensionalityError as e:\n        raise ValueError(e) from e\n    except KeyError as e:\n        # this should not be considered a validation error\n        # raising a type error with extra information\n        raise TypeError(f\"unknown unit registry context {e}\") from e\n\n    raise ValueError(f\"unknown type {type(v)}\")\n</code></pre>"},{"location":"api/quantity/#pydantic_pint.quantity.PydanticPintQuantity.serialize","title":"serialize","text":"<pre><code>serialize(v, info=None, *, to_json=False)\n</code></pre> <p>Serialize <code>PydanticPintQuantity</code>.</p> PARAMETER DESCRIPTION <code>v</code> <p>The quantity that should be serialized.</p> <p> TYPE: <code>PlainQuantity</code> </p> <code>info</code> <p>The serialization info provided by the Pydantic schema.</p> <p> TYPE: <code>SerializationInfo | None</code> DEFAULT: <code>None</code> </p> <code>to_json</code> <p>Whether or not to serialize to a json convertible object. Useful if using <code>PydantiPintQuantity</code> as a utility outside of Pydantic models.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>dict | str | PlainQuantity</code> <p>The serialized <code>pint.Quantity</code>.</p> Source code in <code>src/pydantic_pint/quantity.py</code> <pre><code>def serialize(\n    self,\n    v: Quantity,\n    info: core_schema.SerializationInfo | None = None,\n    *,\n    to_json: bool = False,\n) -&gt; dict | str | Quantity:\n    \"\"\"Serialize `PydanticPintQuantity`.\n\n    Args:\n        v:\n            The quantity that should be serialized.\n        info:\n            The serialization info provided by the Pydantic schema.\n        to_json:\n            Whether or not to serialize to a json convertible object.\n            Useful if using `PydantiPintQuantity` as a utility outside of Pydantic models.\n\n    Returns:\n        The serialized `pint.Quantity`.\n    \"\"\"\n    to_json = to_json or (info and info.mode_is_json())\n\n    if self.ser_mode == \"dict\":\n        return {\n            \"magnitude\": v.magnitude,\n            \"units\": v.units if not to_json else f\"{v.units}\",\n        }\n\n    if self.ser_mode == \"str\" or to_json:\n        return f\"{v}\"\n\n    return v\n</code></pre>"},{"location":"api/quantity/#pydantic_pint.quantity.PydanticPintQuantity.__get_pydantic_core_schema__","title":"__get_pydantic_core_schema__","text":"<pre><code>__get_pydantic_core_schema__(source_type, handler)\n</code></pre> <p>Gets the Pydantic core schema.</p> PARAMETER DESCRIPTION <code>source_type</code> <p>The source type.</p> <p> TYPE: <code>Any</code> </p> <code>handler</code> <p>The <code>GetCoreSchemaHandler</code> instance.</p> <p> TYPE: <code>GetCoreSchemaHandler</code> </p> RETURNS DESCRIPTION <code>CoreSchema</code> <p>The Pydantic core schema.</p> Source code in <code>src/pydantic_pint/quantity.py</code> <pre><code>def __get_pydantic_core_schema__(\n    self,\n    source_type: Any,\n    handler: GetCoreSchemaHandler,\n) -&gt; core_schema.CoreSchema:\n    \"\"\"Gets the Pydantic core schema.\n\n    Args:\n        source_type:\n            The source type.\n        handler:\n            The `GetCoreSchemaHandler` instance.\n\n    Returns:\n        The Pydantic core schema.\n    \"\"\"\n    _from_typedict_schema = {\n        \"magnitude\": core_schema.typed_dict_field(\n            core_schema.str_schema(coerce_numbers_to_str=True)\n        ),\n        \"units\": core_schema.typed_dict_field(core_schema.str_schema()),\n    }\n\n    validate_schema = core_schema.chain_schema(\n        [\n            core_schema.union_schema(\n                [\n                    core_schema.is_instance_schema(Quantity),\n                    core_schema.str_schema(coerce_numbers_to_str=True),\n                    core_schema.typed_dict_schema(_from_typedict_schema),\n                ]\n            ),\n            core_schema.with_info_plain_validator_function(self.validate),\n        ]\n    )\n\n    validate_json_schema = core_schema.chain_schema(\n        [\n            core_schema.union_schema(\n                [\n                    core_schema.str_schema(coerce_numbers_to_str=True),\n                    core_schema.typed_dict_schema(_from_typedict_schema),\n                ]\n            ),\n            core_schema.no_info_plain_validator_function(self.validate),\n        ]\n    )\n\n    serialize_schema = core_schema.plain_serializer_function_ser_schema(\n        self.serialize,\n        info_arg=True,\n    )\n\n    return core_schema.json_or_python_schema(\n        json_schema=validate_json_schema,\n        python_schema=validate_schema,\n        serialization=serialize_schema,\n    )\n</code></pre>"}]}